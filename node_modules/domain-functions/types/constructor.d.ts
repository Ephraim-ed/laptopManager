import type { DomainFunction, ParserSchema } from './types.js';
import { Composable } from './composable/index.js';
declare function dfResultFromcomposable<T extends Composable, R>(fn: T): Composable<(...args: Parameters<T>) => R>;
/**
 * Creates a domain function.
 * After giving the input and environment schemas, you can pass a handler function that takes type safe input and environment. That function is gonna catch any errors and always return a Result.
 * @param inputSchema the schema for the input
 * @param environmentSchema the schema for the environment
 * @returns a handler function that takes type safe input and environment
 * @example
 * const safeFunction = makeDomainFunction(
 *  z.object({ greeting: z.string() }),
 *  z.object({ user: z.object({ name: z.string() }) }),
 * )
 * const myDf = safeFunction(({ greeting }, { user }) => {
 *   return { message: `${greeting} ${user.name}` }
 * })
 */
declare function makeDomainFunction<I, E>(inputSchema?: ParserSchema<I>, environmentSchema?: ParserSchema<E>): <Output>(handler: (input: I, environment: E) => Output) => DomainFunction<Awaited<Output>>;
declare function toComposable<I = unknown, E = unknown, O = unknown>(df: DomainFunction<O>): Composable<(input?: I, environment?: E) => O>;
declare function fromComposable<I, E, A extends Composable>(fn: A, inputSchema?: ParserSchema<I>, environmentSchema?: ParserSchema<E>): DomainFunction<Awaited<ReturnType<A>>>;
export { dfResultFromcomposable, fromComposable, makeDomainFunction, makeDomainFunction as mdf, toComposable, };
