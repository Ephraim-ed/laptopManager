import { errorResultToFailure, failureToErrorResult } from './errors.js';
import { composable } from './composable/composable.js';
function dfResultFromcomposable(fn) {
    return (async (...args) => {
        const r = await fn(...args);
        return r.success
            ? { ...r, inputErrors: [], environmentErrors: [] }
            : failureToErrorResult(r);
    });
}
function formatSchemaErrors(errors) {
    return errors.map((error) => {
        const { path, message } = error;
        return { path: path.map(String), message };
    });
}
/**
 * Creates a domain function.
 * After giving the input and environment schemas, you can pass a handler function that takes type safe input and environment. That function is gonna catch any errors and always return a Result.
 * @param inputSchema the schema for the input
 * @param environmentSchema the schema for the environment
 * @returns a handler function that takes type safe input and environment
 * @example
 * const safeFunction = makeDomainFunction(
 *  z.object({ greeting: z.string() }),
 *  z.object({ user: z.object({ name: z.string() }) }),
 * )
 * const myDf = safeFunction(({ greeting }, { user }) => {
 *   return { message: `${greeting} ${user.name}` }
 * })
 */
function makeDomainFunction(inputSchema, environmentSchema) {
    return function (handler) {
        return fromComposable(composable(handler), inputSchema, environmentSchema);
    };
}
function toComposable(df) {
    return ((input = undefined, environment = {}) => df(input, environment).then((r) => r.success ? r : errorResultToFailure(r)));
}
function fromComposable(fn, inputSchema, environmentSchema) {
    return async function (input, environment = {}) {
        const envResult = await (environmentSchema ?? objectSchema).safeParseAsync(environment);
        const result = await (inputSchema ?? undefinedSchema).safeParseAsync(input);
        if (!result.success || !envResult.success) {
            return {
                success: false,
                errors: [],
                inputErrors: result.success
                    ? []
                    : formatSchemaErrors(result.error.issues),
                environmentErrors: envResult.success
                    ? []
                    : formatSchemaErrors(envResult.error.issues),
            };
        }
        return dfResultFromcomposable(fn)(...[result.data, envResult.data]);
    };
}
const objectSchema = {
    safeParseAsync: (data) => {
        if (Object.prototype.toString.call(data) !== '[object Object]') {
            return Promise.resolve({
                success: false,
                error: { issues: [{ path: [], message: 'Expected an object' }] },
            });
        }
        const someRecord = data;
        return Promise.resolve({ success: true, data: someRecord });
    },
};
const undefinedSchema = {
    safeParseAsync: (data) => {
        if (data !== undefined) {
            return Promise.resolve({
                success: false,
                error: { issues: [{ path: [], message: 'Expected undefined' }] },
            });
        }
        return Promise.resolve({ success: true, data });
    },
};
export { dfResultFromcomposable, fromComposable, makeDomainFunction, makeDomainFunction as mdf, toComposable, };
